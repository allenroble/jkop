/*
* This file is part of Jkop Mix
* Copyright (c) 2017 Job and Esther Technologies Oy
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

class is Node:

var anchors protected as HTMLCollection
var characterSet protected as string
prop body as Body
prop compatMode as string
prop contentType as string
prop doctype as DocumentType
prop documentElement as Element
prop documentURI as string
prop embeds as HTMLCollection
prop forms as HTMLCollection
prop head as Head
prop hidden as bool
prop images as HTMLCollection
prop implementation as DOMImplementation
prop lastStyleSheetSet as string
prop links as HTMLCollection
prop mozSyntheticDocument as bool
prop plugins as vector<Embed>
prop featurePolicy as FeaturePolicy
prop scripts as vector<Script>
prop scrollingElement as Element
prop timeline as DocumentTimeline
prop visibilityState as string

func getAnchors as HTMLCollection:
	return anchors

func getCharacterSet as string:
	return characterSet

func getImages as HTMLCollection
{
	var v = new NodeFinder()
	v.setCondition(func(node as Node) as bool {
		return node is Img
	})
	accept(v)
	var collection = new HTMLCollection()
	foreach node as Img in v.getResult():
		collection.addElement(node)
	return collection
}

func getForms as HTMLCollection
{
	var v = new NodeFinder()
	v.setCondition(func(node as Node) as bool {
		return node is Form
	})
	accept(v)
	var collection = new HTMLCollection()
	foreach node as Form in v.getResult():
		collection.addElement(node)
	return collection
}

func createAttribute(name as string) as Attr:
	return Attr.instance(name)

func createComment(data as string) as Comment:
	return Comment.forText(data)

func createDocumentFragment as DocumentFragment:
	return new DocumentFragment()

func createElement(name as string) as Element
{
	var elem as Element
	if String.equalsIgnoreCase(name, "Div") {
		elem = new Div()
	}
	else if String.equalsIgnoreCase(name, "Small") {
		elem = new Small()
	}
	else if String.equalsIgnoreCase(name, "Img") {
		elem = new Img()
	}
	else if String.equalsIgnoreCase(name, "Form") {
		elem = new Form()
	}
	else if String.equalsIgnoreCase(name, "Embed") {
		elem = new Embed()
	}
	else if String.equalsIgnoreCase(name, "Link") {
		elem = new Link()
	}
	else if String.equalsIgnoreCase(name, "Meta") {
		elem = new Meta()
	}
	else if String.equalsIgnoreCase(name, "A") {
		elem = new A()
	}
	else if String.equalsIgnoreCase(name, "Area") {
		elem = new Area()
	}
	else if String.equalsIgnoreCase(name, "Base") {
		elem = new Base()
	}
	else if String.equalsIgnoreCase(name, "Basefont") {
		elem = new Basefont()
	}
	else if String.equalsIgnoreCase(name, "Body") {
		elem = new Body()
	}
	else if String.equalsIgnoreCase(name, "Br") {
		elem = new Br()
	}
	else if String.equalsIgnoreCase(name, "Button") {
		elem = new Button()
	}
	else if String.equalsIgnoreCase(name, "Canvas") {
		elem = new Canvas()
	}
	else if String.equalsIgnoreCase(name, "Caption") {
		elem = new Caption()
	}
	else if String.equalsIgnoreCase(name, "Col") {
		elem = new Col()
	}
	else if String.equalsIgnoreCase(name, "Data") {
		elem = new Data()
	}
	else if String.equalsIgnoreCase(name, "Datalist") {
		elem = new Datalist()
	}
	else if String.equalsIgnoreCase(name, "Details") {
		elem = new Details()
	}
	else if String.equalsIgnoreCase(name, "Dialog") {
		elem = new Dialog()
	}
	else if String.equalsIgnoreCase(name, "Dl") {
		elem = new Dl()
	}
	else if String.equalsIgnoreCase(name, "Fieldset") {
		elem = new Fieldset()
	}
	else if String.equalsIgnoreCase(name, "Font") {
		elem = new Font()
	}
	else if String.equalsIgnoreCase(name, "Form") {
		elem = new Form()
	}
	else if String.equalsIgnoreCase(name, "Frameset") {
		elem = new Frameset()
	}
	else if String.equalsIgnoreCase(name, "H1") {
		elem = new H1()
	}
	else if String.equalsIgnoreCase(name, "H2") {
		elem = new H2()
	}
	else if String.equalsIgnoreCase(name, "H3") {
		elem = new H3()
	}
	else if String.equalsIgnoreCase(name, "H4") {
		elem = new H4()
	}
	else if String.equalsIgnoreCase(name, "H5") {
		elem = new H5()
	}
	else if String.equalsIgnoreCase(name, "H6") {
		elem = new H6()
	}
	else if String.equalsIgnoreCase(name, "Head") {
		elem = new Head()
	}
	else if String.equalsIgnoreCase(name, "Hr") {
		elem = new Hr()
	}
	else if String.equalsIgnoreCase(name, "Html") {
		elem = new Html()
	}
	else if String.equalsIgnoreCase(name, "Iframe") {
		elem = new Iframe()
	}
	else if String.equalsIgnoreCase(name, "Img") {
		elem = new Img()
	}
	else if String.equalsIgnoreCase(name, "Input") {
		elem = new Input()
	}
	else if String.equalsIgnoreCase(name, "Label") {
		elem = new Label()
	}
	else if String.equalsIgnoreCase(name, "Legend") {
		elem = new Legend()
	}
	else if String.equalsIgnoreCase(name, "Li") {
		elem = new Li()
	}
	else if String.equalsIgnoreCase(name, "Link") {
		elem = new Link()
	}
	else if String.equalsIgnoreCase(name, "Meter") {
		elem = new Meter()
	}
	else if String.equalsIgnoreCase(name, "Object") {
		elem = new Object()
	}
	else if String.equalsIgnoreCase(name, "Optgroup") {
		elem = new Optgroup()
	}
	else if String.equalsIgnoreCase(name, "Option") {
		elem = new Option()
	}
	else if String.equalsIgnoreCase(name, "Output") {
		elem = new Output()
	}
	else if String.equalsIgnoreCase(name, "P") {
		elem = new P()
	}
	else if String.equalsIgnoreCase(name, "Param") {
		elem = new Param()
	}
	else if String.equalsIgnoreCase(name, "Picture") {
		elem = new Picture()
	}
	else if String.equalsIgnoreCase(name, "Pre") {
		elem = new Pre()
	}
	else if String.equalsIgnoreCase(name, "Pre") {
		elem = new Pre()
	}
	else if String.equalsIgnoreCase(name, "Progress") {
		elem = new Progress()
	}
	else if String.equalsIgnoreCase(name, "Select") {
		elem = new Select()
	}
	else if String.equalsIgnoreCase(name, "Small") {
		elem = new Small()
	}
	else if String.equalsIgnoreCase(name, "Source") {
		elem = new Source()
	}
	else if String.equalsIgnoreCase(name, "Span") {
		elem = new Span()
	}
	else if String.equalsIgnoreCase(name, "Table") {
		elem = new Table()
	}
	else if String.equalsIgnoreCase(name, "Td") {
		elem = new Td()
	}
	else if String.equalsIgnoreCase(name, "Template") {
		elem = new Template()
	}
	else if String.equalsIgnoreCase(name, "Textarea") {
		elem = new Textarea()
	}
	else if String.equalsIgnoreCase(name, "Tfoot") {
		elem = new Tfoot()
	}
	else if String.equalsIgnoreCase(name, "Thead") {
		elem = new Thead()
	}
	else if String.equalsIgnoreCase(name, "Time") {
		elem = new Time()
	}
	else if String.equalsIgnoreCase(name, "Title") {
		elem = new Title()
	}
	else if String.equalsIgnoreCase(name, "Tr") {
		elem = new Tr()
	}
	else if String.equalsIgnoreCase(name, "Track") {
		elem = new Track()
	}
	else {
		ERROR "Element not supported"
	}
	return elem
}

func createEvent(type as string) as Event:
	return new Event(type, null)

func createNodeIterator(root as Node, whatToShow as long = 0, filter as NodeFilter) as NodeIterator:
	return NodeIterator.instance(root, whatToShow, filter)

func createRange as Range:
	return new Range()

func createTextNode(data as string) as Text:
	return Text.forText(data)

func createTreeWalker(root as Node, whatToShow as long = 0, filter as NodeFilter = null, entityReferenceExpansion as bool = false) as TreeWalker:
	return TreeWalker.instance(root, whatToShow, filter, entityReferenceExpansion)

func getElementsByClassName(name as string) as HTMLCollection
{
	assert name
	var v = new NodeFinder()
	v.setCondition(func(node as Node) as bool {
		if node is Element && String.equals(name, (node as! Element).getClassName()):
			return true
		return false
	})
	accept(v)
	var collection = new HTMLCollection()
	foreach node as Element in v.getResult():
		collection.addElement(node)
	return collection
}

func getElementsByTagName(name as string) as HTMLCollection
{
	assert name
	var v = new NodeFinder()
	v.setCondition(func(node as Node) as bool {
		if node is Element && String.equals(name, (node as! Element).getTagName()):
			return true
		return false
	})
	accept(v)
	var collection = new HTMLCollection()
	foreach node as Element in v.getResult():
		collection.addElement(node)
	return collection
}

func getElementsByTagNameNS(namespace as string, name as string) as NodeList
{
	assert namespace
	assert name
	assert name
	var v = new NodeFinder()
	v.setCondition(func(node as Node) as bool {
		if node is Element {
			var elem = node as! Element
			if String.equals(elem.getLocalName(), name) && String.equals(elem.getNameSpaceURI(), namespace):
				return true
		}
		return false
	})
	accept(v)
	var list = new NodeList()
	foreach node in v.getResult():
		list.addNode(node)
	return list
}

func getElementById(id as string) as Element
{
	assert id
	var v = new NodeFinder()
	v.setCondition(func(node as Node) as bool {
		if node is Element && String.equals(id, (node as! Element).getId()):
			return true
		return false
	})
	v.setShouldEndOnMatch(true)
	accept(v)
	return Vector.getFirst(v.getResult())
}

func adoptNode(externalNode as Node) stub
func caretRangeFromPoint(x as double, y as double) stub as Range
func createCDATASection(data as string) stub as CDATASection
func createElementNS(namespaceURI as string, qualifiedName as string, option as object = null) stub as Element
func createProcessingInstruction(target as string, data as string) stub as ProcessingInstruction
func createTouch(view as object, target as EventTarget, identifier as long, pageX as long, pageY as long, screenX as long, screenY as long) stub as object
func createTouchList(touch as vector<object>) stub as object
func enableStyleSheetsForSet(name as string) stub
func exitPointerLock stub
func hasStorageAccess stub as Promise
func importNode(externalNode as Node, deep as bool) stub as Node
func releaseCapture stub
func requestStorageAccess stub as Promise
func mozSetImageElement(imageElementId as string, imageElement as Element) stub
func querySelector(selector as string) stub as HTMLElement
func querySelectorAll(selectors as vector<string>) stub as NodeList
func createExpression(xpathText as string, namespaceURLMapper as function) stub as XPathExpression
func createNSResolver stub as XPathNSResolver
func evaluate(xpathExpression as string, contextNode as this, namespaceResolver as function, resultType as int, result as XPathResult) stub as XPathResult

func duplicate override as Node
{
	var v = new this()
	assert copyTo(v)
	return v
}

func copyTo(node as this) as bool
{
	assert base.copyTo(node)
	node.characterSet = characterSet
	node.setCompatMode(compatMode)
	node.setContentType(contentType)
	node.setDoctype(doctype)
	node.setHidden(hidden)
	node.setImplementation(implementation)
	node.setFeaturePolicy(featurePolicy)
	return true
}


/*
* This file is part of Jkop Mix
* Copyright (c) 2017 Job and Esther Technologies Oy
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

class <T>:

prop array as array<T>

ctor(array as array<T>):
	this.array = array

ctor:
	array = new array<T>

func toString as string
{
	assert array
	var sb as string
	for(var n = 0; n < getSize(); n++) {
		if !sb {
			sb = String.asString(array[n])
		}
		else {
			sb = sb .. ", " .. String.asString(array[n])
		}
	}
	return sb
}

func join(separator as string = null) as string
{
	assert array
	if not separator:
		return toString()
	var sb as string
	for(var n = 0; n < getSize(); n++) {
		if not sb {
			sb = String.asString(array[n])
		}
		else {
			sb = sb .. separator .. String.asString(array[n])
		}
	}
	return sb
}

func slice(fromIndex as int = 0, toIndex as int = 0) as array<T>
{
	assert array
	var v = new array<T>
	if toIndex == 0:
		toIndex = getSize() - 1
	var index as int
	while fromIndex < toIndex {
		v[index] = getAt(fromIndex)
		fromIndex++
		index++
	}
	return v
}

func getSize as int:
	return SIZE array

func getAt(index as int) as T
{
	assert array
	if index < getSize():
		return array[index]
	return null
}

func setAt(index as int, item as T)
{
	if !array:
		array = new array<T>
	array[index] = item
}

func indexOf(object as T) as int
{
	assert array
	for(var n = 0; n < getSize(); n++) {
		if array[n] == object:
			return n
	}
	return -1
}

func lastIndexOf(object as T, fromIndex as int = 0) as int
{
	assert array
	if fromIndex < 1:
		fromIndex = getSize() - 1
	while fromIndex >= 0 {
		if array[fromIndex] == object:
			return fromIndex
		fromIndex--
	}
	return -1
}

func push(object as T) as int
{
	assert array
	setAt(getSize(), object)
	return getSize()
}

func reverse
{
	assert array
	var a = 0
	var b = getSize() - 1
	while a < b {
		var t = getAt(b)
		setAt(b, getAt(a))
		setAt(a, t)
		a ++
		b --
	}
}

func splice(index as int, deleteCount as int = 0, addedItem as T = null) as array<T>
{
	assert array
	var v = new array<T>
	for(var n = 0; n < deleteCount; n++) {
		v += array[index]
		if n == 0 && addedItem {
			setAt(index, addedItem)
		}
		else {
			removeByIndex(index)
		}
	}
	return v
}

func shift as T:
	return removeByIndex(0)

func removeByIndex(index as int) as T
{
	assert array
	var vec = Array.toVector(array)
	var removedValue = Vector.remove(vec, index)
	array = vec
	return removedValue
}

func includes(object as T) as bool:
	return jk.lang.Array.contains(array, object)

func isArray(object as dynamic) static as bool:
	return object is array

func flat as array<T>
{
	assert array
	var size = SIZE array
	var newSize as int
	var v = new array<T>
	for(var n = 0; n < size; n++) {
			var nextIndex = n
			var newValue = null
			loop {
				newValue = getAt(nextIndex)
				if newValue || nextIndex >= size:
					break
				nextIndex++
			}
			if newValue:
				v += newValue
	}
	return v
}

func pop as T:
	return removeByIndex(getSize() - 1)

func filter(fn as function) stub
func find(fn as function) stub
func reduce(fn as function, init as T) stub
func forEach(fn as function) stub
func some(fn as function) stub
func map(fn as function) stub

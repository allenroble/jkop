
/*
* This file is part of Jkop Mix
* Copyright (c) 2017 Job and Esther Technologies Oy
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TLO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

class:

prop value as string

class TokenIterator
{
	ctor(tokens as vector<string>)
	{
		this.tokens = tokens
		this.index = 0
	}

	var index protected as int
	var tokens protected as vector<string>

	func hasNext as bool
	{
		assert tokens
		assert index < (SIZE tokens) - 1
		return true
	}
}

func contains(token as string) as bool:
	return Vector.contains(tokens, token)

func supports(token as string) stub as bool

func toggle(token as string) as bool
{
	assert tokens
	if contains(token) {
		remove(token)
	}
	else {
		add(token)
	}
	return contains(token)
}

class TokenKeyValueIterator is TokenIterator is Iterator<KeyValuePair<int, string>>
{
	ctor(tokens as vector<string>):
		base(tokens)

	func next as KeyValuePair<int, string>
	{
		assert tokens
		if index < 0 || index >= SIZE tokens:
			return null
		var token = Vector.get(tokens, index)
		index ++
		var v = new KeyValuePair<int,string>()
		v.key = index
		v.value = token
		return v
	}

	func hasNext as bool:
		return base.hasNext()
}

class TokenKeysIterator is TokenIterator is Iterator<int>
{
	ctor(tokens as vector<string>):
		base(tokens)

	func next as int
	{
		assert tokens
		if index < 0 || index >= SIZE tokens:
			return 0
		var i = index
		index ++
		return i
	}

	func hasNext as bool:
		return base.hasNext()
}

class TokenValueIterator is TokenIterator is Iterator<string>
{
	ctor(tokens as vector<string>):
		base(tokens)

	func next as int
	{
		assert tokens
		if index < 0 || index >= SIZE tokens:
			return null
		var token = Vector.get(tokens, index)
		index ++
		return token
	}

	func hasNext as bool:
		return base.hasNext()
}

var tokens as vector<string>

func getLength as int:
	return Vector.getSize(tokens)

func item(index as int) as string #subscriptGet
{
	assert tokens
	if index < 0 || index >= SIZE tokens:
		return null
	return Vector.get(tokens, index)
}

func entries as Iterator<KeyValuePair<int, string>>:
	return new TokenKeyValueIterator(tokens)

func keys as Iterator<int>:
	return new TokenKeysIterator(tokens)

func values as Iterator<string>:
	return new TokenValueIterator(tokens)

func add(tkns as string)
{
	assert tokens
	if not tokens:
		tokens = new vector<string>
	tokens += tkns as string
}

func remove(tkn as string)
{
	assert tokens
	Vector.removeValue(tokens, tkn)
}

func getTokens as vector<string>:
	return tokens

func replace(oldToken as string, newToken as string) as bool
{
	assert tokens
	Vector.set(tokens, Vector.removeValue(tokens, oldToken), newToken)
	return contains(newToken)
}

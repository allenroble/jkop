/*
* This file is part of Jkop Mix
* Copyright (c) 2017 Job and Esther Technologies Oy
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TLO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

class:

class NodeListIterator
{
	ctor(nodes as vector<Node>)
	{
		this.nodes = nodes
		this.index = 0
	}

	var index protected as int
	var nodes protected as vector<Node>

	func hasNext as bool
	{
		assert nodes
		assert (index - 1) < (SIZE nodes)
		return true
	}
}

class NodeListKeyValueIterator is NodeListIterator is Iterator<KeyValuePair<int, Node>>
{
	ctor(nodes as vector<Node>):
		base(nodes)

	func next as KeyValuePair<int, Node>
	{
		assert nodes
		if index < 0 || index >= SIZE nodes:
			return null
		var node = Vector.get(nodes, index)
		index ++
		return new KeyValuePair<int, Node>(index, node)
	}

	func hasNext as bool:
		return base.hasNext()
}

class NodeKeysIterator is NodeListIterator is Iterator<int>
{
	ctor(nodes as vector<Node>):
		base(nodes)

	func next as int
	{
		assert nodes
		if index < 0 || index >= SIZE nodes:
			return 0
		var i = index
		index ++
		return i
	}

	func hasNext as bool:
		return base.hasNext()
}

class NodeValueIterator is NodeListIterator is Iterator<Node>
{
	ctor(nodes as vector<Node>):
		base(nodes)

	func next as Node
	{
		assert nodes
		if index < 0 || index >= SIZE nodes:
			return null
		var node = Vector.get(nodes, index)
		index ++
		return node
	}

	func hasNext as bool:
		return base.hasNext()
}

var nodes as vector<Node>

func getLength as int:
	return Vector.getSize(nodes)

func item(index as int) as Node #subscriptGet
{
	assert nodes
	if index < 0 || index >= SIZE nodes:
		return null
	return Vector.get(nodes, index)
}

func entries as Iterator<KeyValuePair<int, Node>>:
	return new NodeListKeyValueIterator(nodes)

func keys as Iterator<int>:
	return new NodeKeysIterator(nodes)

func values as Iterator<Node>:
	return new NodeValueIterator(nodes)

func addNode(node as Node)
{
	assert node
	if not nodes:
		nodes = new vector<Node>
	nodes += node
}

func removeNode(node as Node) as Node
{
	assert nodes
	Vector.removeValue(nodes, node)
	return node
}

func getNodes as vector<Node>:
	return nodes

func replaceNode(oldNode as Node, newNode as Node) as Node
{
	assert nodes
	Vector.set(nodes, Vector.removeValue(nodes, oldNode), newNode)
	return oldNode
}
